#include "stdafx.h"
#include <iostream>  
#include <bitset>  
#include <string>  
#include<vector>
#include<math.h>
#include <iomanip>

using namespace std;

//////////////////////////////////////////////////////////////////////////////////////////////
//AES 加解密相关算法开始
unsigned char sBox[256] = {
	0x9C,0x6C,0xF4,0x32,0xAE,0x75,0x9F,0x3A,0x4F,0x0F,0xD9,0x09,0x5A,0xC2,0xCB,0x61,
	0x7B,0x04,0xE2,0x25,0x9D,0x2E,0x23,0x1E,0xDB,0x83,0x5C,0x6A,0xB7,0x5E,0xC4,0x26,
	0xBE,0xE3,0x15,0x6F,0x56,0x31,0xFE,0x0E,0xBA,0x00,0x6D,0xE0,0x9E,0xAF,0xD0,0x0A,
	0x73,0x7A,0x78,0x8E,0x99,0x71,0xE8,0xA6,0x63,0x6E,0x86,0x14,0x0D,0x97,0x96,0x80,
	0xAD,0xBD,0x48,0x12,0xB0,0xEB,0xCA,0x6B,0x52,0xB4,0x35,0xB3,0x5D,0x2C,0x2A,0xF6,
	0x9B,0xE6,0xA2,0xD8,0x89,0xCE,0xDD,0x2B,0x44,0x59,0xF0,0xF2,0xA9,0x22,0x7F,0xEC,
	0x40,0x8D,0xA4,0x5B,0x8F,0x0C,0xB1,0xAC,0x46,0x3F,0xA3,0x01,0xAA,0x57,0x1C,0xF8,
	0xF1,0xFF,0x81,0x10,0xBB,0xDF,0x60,0x41,0xC3,0xF5,0xD1,0x38,0xD7,0x47,0x1F,0xCC,
	0xC1,0x27,0x82,0xCD,0xEE,0x90,0x4D,0x98,0xD3,0xBF,0xE5,0x19,0x70,0x49,0xB6,0xE4,
	0xB9,0x93,0x1D,0x24,0x8A,0x88,0x91,0xD2,0x76,0x17,0x69,0x58,0x68,0x66,0x16,0xB8,
	0x7E,0x29,0x05,0xC9,0x3C,0x21,0x92,0x1B,0xA1,0xA7,0xFD,0x1A,0xE7,0x30,0x33,0x9A,
	0x54,0xFB,0x08,0xAB,0x87,0xCF,0xA5,0x4C,0x5F,0xF3,0xF9,0x2F,0x03,0x39,0xFC,0x28,
	0x8B,0xC5,0x42,0x4A,0x37,0x4E,0x94,0x95,0xD4,0xBC,0x3E,0x72,0xED,0xEA,0x74,0x77,
	0x3B,0x45,0x34,0x20,0xC0,0xC7,0x8C,0x0B,0x67,0xDC,0x62,0xEF,0x2D,0x50,0x13,0x84,
	0xE1,0x07,0x4B,0x3D,0x06,0x7D,0xD6,0x11,0x64,0xD5,0xA0,0x43,0xB2,0xE9,0x02,0x65,
	0xB5,0x36,0x18,0xA8,0xDE,0x7C,0xFA,0xDA,0x51,0xC6,0x85,0xF7,0x53,0x79,0xC8,0x55 };

unsigned char invsBox[256] = {
	0x29,0x6B,0xEE,0xBC,0x11,0xA2,0xE4,0xE1,0xB2,0x0B,0x2F,0xD7,0x65,0x3C,0x27,0x09,
	0x73,0xE7,0x43,0xDE,0x3B,0x22,0x9E,0x99,0xF2,0x8B,0xAB,0xA7,0x6E,0x92,0x17,0x7E,
	0xD3,0xA5,0x5D,0x16,0x93,0x13,0x1F,0x81,0xBF,0xA1,0x4E,0x57,0x4D,0xDC,0x15,0xBB,
	0xAD,0x25,0x03,0xAE,0xD2,0x4A,0xF1,0xC4,0x7B,0xBD,0x07,0xD0,0xA4,0xE3,0xCA,0x69,
	0x60,0x77,0xC2,0xEB,0x58,0xD1,0x68,0x7D,0x42,0x8D,0xC3,0xE2,0xB7,0x86,0xC5,0x08,
	0xDD,0xF8,0x48,0xFC,0xB0,0xFF,0x24,0x6D,0x9B,0x59,0x0C,0x63,0x1A,0x4C,0x1D,0xB8,
	0x76,0x0F,0xDA,0x38,0xE8,0xEF,0x9D,0xD8,0x9C,0x9A,0x1B,0x47,0x01,0x2A,0x39,0x23,
	0x8C,0x35,0xCB,0x30,0xCE,0x05,0x98,0xCF,0x32,0xFD,0x31,0x10,0xF5,0xE5,0xA0,0x5E,
	0x3F,0x72,0x82,0x19,0xDF,0xFA,0x3A,0xB4,0x95,0x54,0x94,0xC0,0xD6,0x61,0x33,0x64,
	0x85,0x96,0xA6,0x91,0xC6,0xC7,0x3E,0x3D,0x87,0x34,0xAF,0x50,0x00,0x14,0x2C,0x06,
	0xEA,0xA8,0x52,0x6A,0x62,0xB6,0x37,0xA9,0xF3,0x5C,0x6C,0xB3,0x67,0x40,0x04,0x2D,
	0x44,0x66,0xEC,0x4B,0x49,0xF0,0x8E,0x1C,0x9F,0x90,0x28,0x74,0xC9,0x41,0x20,0x89,
	0xD4,0x80,0x0D,0x78,0x1E,0xC1,0xF9,0xD5,0xFE,0xA3,0x46,0x0E,0x7F,0x83,0x55,0xB5,
	0x2E,0x7A,0x97,0x88,0xC8,0xE9,0xE6,0x7C,0x53,0x0A,0xF7,0x18,0xD9,0x56,0xF4,0x75,
	0x2B,0xE0,0x12,0x21,0x8F,0x8A,0x51,0xAC,0x36,0xED,0xCD,0x45,0x5F,0xCC,0x84,0xDB,
	0x5A,0x70,0x5B,0xB9,0x02,0x79,0x4F,0xFB,0x6F,0xBA,0xF6,0xB1,0xBE,0xAA,0x26,0x71 };

void AddRoundKey(unsigned char *input, unsigned char *key)
{
	for (int i = 0; i < 4; i++)
	{
		input[0 * 4 + i] ^= key[i * 4 + 0];
		input[1 * 4 + i] ^= key[i * 4 + 1];
		input[3 * 4 + i] ^= key[i * 4 + 2];
		input[2 * 4 + i] ^= key[i * 4 + 3];
	}
}

void SubBytes(unsigned char *input)
{
	for (int i = 0; i < 16; i++)
	{
		input[i] = sBox[input[i]];
	}
}

void InvSubBytes(unsigned char *input)
{
	for (int i = 0; i < 16; i++)
	{
		input[i] = invsBox[input[i]];
	}
}

void ShiftRow(unsigned char *input)
{
	unsigned char cpinput[16];
	memcpy(cpinput, input, 16);

	input[5] = cpinput[1];
	input[9] = cpinput[5];
	input[13] = cpinput[9];
	input[1] = cpinput[13];
	input[10] = cpinput[2];
	input[14] = cpinput[6];
	input[2] = cpinput[10];
	input[6] = cpinput[14];
	input[15] = cpinput[3];
	input[3] = cpinput[7];
	input[7] = cpinput[11];
	input[11] = cpinput[15];
}

void InvShiftRow(unsigned char *input)
{
	unsigned char cpinput[16];
	memcpy(cpinput, input, 16);

	input[1] = cpinput[5];
	input[5] = cpinput[9];
	input[9] = cpinput[13];
	input[13] = cpinput[1];
	input[2] = cpinput[10];
	input[6] = cpinput[14];
	input[10] = cpinput[2];
	input[14] = cpinput[6];
	input[3] = cpinput[15];
	input[7] = cpinput[3];
	input[11] = cpinput[7];
	input[15] = cpinput[11];
}

unsigned char FFmul(unsigned char a, unsigned char b)
{
	unsigned char bw[4];
	unsigned char res = 0;
	int i;
	bw[0] = b;
	for (i = 1; i<4; i++)
	{
		bw[i] = bw[i - 1] << 1;
		if (bw[i - 1] & 0x80)
		{
			bw[i] ^= 0x1b;
		}
	}
	for (i = 0; i<4; i++)
	{
		if ((a >> i) & 0x01)
		{
			res ^= bw[i];
		}
	}
	return res;
}

void MixColumns(unsigned char *input)
{
	unsigned char cpinput[16];
	memcpy(cpinput, input, 16);

	for (int i = 0; i<4; i++)
	{
		input[i + 0 * 4] = FFmul(0x02, cpinput[i + 0 * 4])
			^ FFmul(0x03, cpinput[i + 1 * 4])
			^ FFmul(0x01, cpinput[i + 2 * 4])
			^ FFmul(0x01, cpinput[i + 3 * 4]);

		input[i + 1 * 4] = FFmul(0x01, cpinput[i + 0 * 4])
			^ FFmul(0x02, cpinput[i + 1 * 4])
			^ FFmul(0x03, cpinput[i + 2 * 4])
			^ FFmul(0x01, cpinput[i + 3 * 4]);

		input[i + 2 * 4] = FFmul(0x01, cpinput[i + 0 * 4])
			^ FFmul(0x01, cpinput[i + 1 * 4])
			^ FFmul(0x02, cpinput[i + 2 * 4])
			^ FFmul(0x03, cpinput[i + 3 * 4]);

		input[i + 3 * 4] = FFmul(0x03, cpinput[i + 0 * 4])
			^ FFmul(0x01, cpinput[i + 1 * 4])
			^ FFmul(0x01, cpinput[i + 2 * 4])
			^ FFmul(0x02, cpinput[i + 3 * 4]);

	}
}

void InvMixColumns(unsigned char *input)
{
	unsigned char cpinput[16];
	memcpy(cpinput, input, 16);

	for (int i = 0; i<4; i++)
	{
		input[i+0 * 4] = FFmul(0x0e, cpinput[i+0*4])
			^ FFmul(0x0b, cpinput[i+ 1 * 4])
			^ FFmul(0x0d, cpinput[i+ 2 * 4])
			^ FFmul(0x09, cpinput[i+ 3 * 4]);

		input[i + 1 * 4] = FFmul(0x09, cpinput[i + 0 * 4])
			^ FFmul(0x0e, cpinput[i + 1 * 4])
			^ FFmul(0x0b, cpinput[i + 2 * 4])
			^ FFmul(0x0d, cpinput[i + 3 * 4]);

		input[i + 2 * 4] = FFmul(0x0d, cpinput[i + 0 * 4])
			^ FFmul(0x09, cpinput[i + 1 * 4])
			^ FFmul(0x0e, cpinput[i + 2 * 4])
			^ FFmul(0x0b, cpinput[i + 3 * 4]);

		input[i + 3 * 4] = FFmul(0x0b, cpinput[i + 0 * 4])
			^ FFmul(0x0d, cpinput[i + 1 * 4])
			^ FFmul(0x09, cpinput[i + 2 * 4])
			^ FFmul(0x0e, cpinput[i + 3 * 4]);

	}
}

void to_row_array(unsigned char *input)
{
	unsigned char cpinput[16];
	memcpy(cpinput, input, 16);

	for (int i = 0; i < 4; i++)
	{
		input[0 * 4 + i] = cpinput[i * 4 + 0];
		input[1 * 4 + i] = cpinput[i * 4 + 1];
		input[2 * 4 + i] = cpinput[i * 4 + 2];
		input[3 * 4 + i] = cpinput[i * 4 + 3];
	}
}

void to_col_array(unsigned char *input)
{
	unsigned char cpinput[16];
	memcpy(cpinput, input, 16);

	for (int i = 0; i < 4; i++)
	{
		input[i * 4 + 0] = cpinput[0 * 4 + i];
		input[i * 4 + 1] = cpinput[1 * 4 + i];
		input[i * 4 + 2] = cpinput[2 * 4 + i];
		input[i * 4 + 3] = cpinput[3 * 4 + i];
	}
}

void to_need_array(unsigned char *input)
{
	unsigned char cpinput[16];
	memcpy(cpinput, input, 16);

	for (int i = 0; i < 4; i++)
	{
		input[0 * 4 + i] = cpinput[i * 4 + 0];
		input[1 * 4 + i] = cpinput[i * 4 + 1];
		input[3 * 4 + i] = cpinput[i * 4 + 2];
		input[2 * 4 + i] = cpinput[i * 4 + 3];
	}
}

void xor_array(unsigned char *input, unsigned char *key)
{
	for (int i = 0; i < 16; i++)
	{
		input[i] ^= key[i];
	}
}

void aes_decrypt(unsigned char *input)
{
	unsigned char key_exp[176] = {
		0x63,0x6C,0x65,0x77,0x67,0x65,0x6D,0x6F,0x62,0x61,0x6C,0x73,0x38,0x31,0x30,0x32,
		0xE3,0x5B,0x72,0x34,0x84,0x3E,0x1F,0x5B,0xE6,0x5F,0x73,0x28,0xDE,0x6E,0x43,0x1A,
		0x4E,0xEC,0x26,0x1E,0xCA,0xD2,0x39,0x45,0x2C,0x8D,0x4A,0x6D,0xF2,0xE3,0x09,0x77,
		0x49,0x4A,0xE7,0xB7,0x83,0x98,0xDE,0xF2,0xAF,0x15,0x94,0x9F,0x5D,0xF6,0x9D,0xE8,
		0xC3,0x9A,0x41,0xA6,0x40,0x02,0x9F,0x54,0xEF,0x17,0x0B,0xCB,0xB2,0xE1,0x96,0x23,
		0x14,0xA1,0x41,0xF8,0x54,0xA3,0xDE,0xAC,0xBB,0xB4,0xD5,0x67,0x09,0x55,0x43,0x44,
		0xB9,0xBF,0x14,0xFB,0xED,0x1C,0xCA,0x57,0x56,0xA8,0x1F,0x30,0x5F,0xFD,0x5C,0x74,
		0xF8,0x1B,0x42,0x1C,0x15,0x07,0x88,0x4B,0x43,0xAF,0x97,0x7B,0x1C,0x52,0xCB,0x0F,
		0x22,0x1F,0x59,0x6E,0x37,0x18,0xD1,0x25,0x74,0xB7,0x46,0x5E,0x68,0xE5,0x8D,0x51,
		0xCB,0xB4,0x37,0x9A,0xFC,0xAC,0xE6,0xBF,0x88,0x1B,0xA0,0xE1,0xE0,0xFE,0x2D,0xB0,
		0x39,0x42,0xEE,0x51,0xC5,0xEE,0x08,0xEE,0x4D,0xF5,0xA8,0x0F,0xAD,0x0B,0x85,0xBF };

	unsigned char *pkey = key_exp + 160;

	unsigned char*aa = input;
	to_row_array(aa);

	unsigned char key[16];
	memcpy(key, pkey, 16);
	AddRoundKey(aa, key);

	for (int i = 0; i < 9; i++)
	{
		SubBytes(aa);
		ShiftRow(aa);
		InvMixColumns(aa);

		memcpy(key, pkey - 16, 16);
		pkey -= 16;

		to_need_array(key);
		InvMixColumns(key);
		xor_array(aa, key);
	}

	SubBytes(aa);
	ShiftRow(aa);

	memcpy(key, key_exp, 16);
	to_need_array(key);
	xor_array(aa, key);

	to_col_array(aa);
}

void aes_encrypt(unsigned char *input)
{
	unsigned char key_exp[176] = {
		0x63,0x6C,0x65,0x77,0x67,0x65,0x6D,0x6F,0x62,0x61,0x6C,0x73,0x38,0x31,0x30,0x32,
		0xE3,0x5B,0x72,0x34,0x84,0x3E,0x1F,0x5B,0xE6,0x5F,0x73,0x28,0xDE,0x6E,0x43,0x1A,
		0x4E,0xEC,0x26,0x1E,0xCA,0xD2,0x39,0x45,0x2C,0x8D,0x4A,0x6D,0xF2,0xE3,0x09,0x77,
		0x49,0x4A,0xE7,0xB7,0x83,0x98,0xDE,0xF2,0xAF,0x15,0x94,0x9F,0x5D,0xF6,0x9D,0xE8,
		0xC3,0x9A,0x41,0xA6,0x40,0x02,0x9F,0x54,0xEF,0x17,0x0B,0xCB,0xB2,0xE1,0x96,0x23,
		0x14,0xA1,0x41,0xF8,0x54,0xA3,0xDE,0xAC,0xBB,0xB4,0xD5,0x67,0x09,0x55,0x43,0x44,
		0xB9,0xBF,0x14,0xFB,0xED,0x1C,0xCA,0x57,0x56,0xA8,0x1F,0x30,0x5F,0xFD,0x5C,0x74,
		0xF8,0x1B,0x42,0x1C,0x15,0x07,0x88,0x4B,0x43,0xAF,0x97,0x7B,0x1C,0x52,0xCB,0x0F,
		0x22,0x1F,0x59,0x6E,0x37,0x18,0xD1,0x25,0x74,0xB7,0x46,0x5E,0x68,0xE5,0x8D,0x51,
		0xCB,0xB4,0x37,0x9A,0xFC,0xAC,0xE6,0xBF,0x88,0x1B,0xA0,0xE1,0xE0,0xFE,0x2D,0xB0,
		0x39,0x42,0xEE,0x51,0xC5,0xEE,0x08,0xEE,0x4D,0xF5,0xA8,0x0F,0xAD,0x0B,0x85,0xBF };

	unsigned char *pkey = key_exp;

	unsigned char*aa = input;
	to_row_array(aa);

	unsigned char key[16];
	memcpy(key, pkey, 16);
	to_need_array(key);
	xor_array(aa, key);
	InvShiftRow(aa);
	InvSubBytes(aa);

	for (int i = 0; i < 9; i++)
	{
		memcpy(key, pkey + 16, 16);
		pkey += 16;

		to_need_array(key);
		InvMixColumns(key);
		xor_array(aa, key);
		
		MixColumns(aa);
		InvShiftRow(aa);
		InvSubBytes(aa);
	}

	memcpy(key, pkey+16, 16);
	to_need_array(key);
	xor_array(aa, key);

	to_col_array(aa);
}
//AES 加解密相关算法结束
//////////////////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////////////////
//base64 加密解密相关
string strBigNum = "ZO6Kq79L&CPWvNopzQfghDRSG@di*kAB8rsFewxlm+/u5a^2YtTJUVEn0$HI34y#=";

bool CheckKey(string strKey)
{
	for (int i = 0; i < strKey.size(); i++)
	{
		bool bRet = false;
		for (int j = 0; j < strBigNum.size(); j++)
		{
			if (strKey[i] == strBigNum[j])
				bRet = true;
		}
		if (bRet == false)
			return false;
	}
	return true;
}

char CalcCh(char ch)
{
	for (int i = 0; i < strBigNum.size(); i++)
	{
		if (ch == strBigNum[i])
			return i ^ (i >> 3);
	}
	return -1;
}

bool CalcKey(string strKey, vector<char> &vec_ch)
{
	for (int i = 0; i < strKey.size(); i += 4)
	{
		char ch1 = CalcCh(strKey[i]);
		char ch2 = CalcCh(strKey[i + 1]);
		char ch3 = CalcCh(strKey[i + 2]);
		char ch4 = CalcCh(strKey[i + 3]);

		char ret = 4 * ch1 | (ch2 >> 4) & 3;
		vec_ch.push_back(ret);

		if (strKey[i + 2] == '=')
			break;

		ret = 16 * ch2 | (ch3 >> 2) & 0xF;
		vec_ch.push_back(ret);

		if (strKey[i + 3] == '=')
			break;

		ret = (ch3 << 6) | ch4 & 0x3F;
		vec_ch.push_back(ret);
	}
	return true;
}

vector<string> split(string str, string pattern)
{
	int pos;
	vector<string> result;
	str += pattern;//扩展字符串以方便操作
	int size = str.size();

	for (int i = 0; i<size; i++)
	{
		pos = str.find(pattern, i);
		if (pos<size)
		{
			std::string s = str.substr(i, pos - i);
			result.push_back(s);
			i = pos + pattern.size() - 1;
		}
	}
	return result;
}

bool CalcCode(string strCode, _int64 &nTmp1, _int64 &nTmp2, _int64 &nTmp3, _int64 &nTmp4, _int64 &nTmp5)
{
	vector<string> vec_code = split(strCode, "#");
	if (vec_code.size() != 8)
	{
		return false;
	}

	nTmp1 = (vec_code[0][0] * vec_code[1][0]) << 16;
	nTmp1 += vec_code[0][1] ^ vec_code[2][1];
	nTmp1 += (vec_code[0][2] % (vec_code[3][2] + 1)) + 1;
	nTmp1 += int(vec_code[0][2] / (vec_code[4][3] + 1));

	nTmp2 = (vec_code[1][0] ^ vec_code[5][0]) << 16;
	nTmp2 += vec_code[1][1] % (vec_code[6][1] + 3);
	nTmp2 += int(vec_code[1][2] / (vec_code[7][2] + 1)) + 5;
	nTmp2 += vec_code[1][3] + vec_code[0][3];

	nTmp3 = int(vec_code[2][0] / (vec_code[1][0] + 3)) << 16;
	nTmp3 ^= vec_code[2][1] % vec_code[3][1];
	nTmp3 += vec_code[2][2] + vec_code[5][2] + 12;
	nTmp3 += vec_code[2][3] + vec_code[7][3];

	nTmp4 = vec_code[0][1] ^ vec_code[2][3];
	nTmp4 *= vec_code[1][3] + vec_code[3][1];
	nTmp4 &= vec_code[4][2] & vec_code[5][2];
	nTmp4 *= vec_code[7][3];
	nTmp4 += nTmp2;
	nTmp4 *= vec_code[6][0];
	nTmp4 *= nTmp1;

	_int64 t2 = nTmp4;
	t2 -= nTmp2;
	_int64 t = nTmp1 * 2;
	t = t2%t;
	nTmp4 -= t;

	nTmp5 = (vec_code[3][0] ^ vec_code[4][0]) << 16;
	nTmp5 = nTmp5 * (vec_code[3][1] % (vec_code[4][1] + 2));
	nTmp5 += (vec_code[3][2] % (vec_code[4][2] + 5)) + 7;
	nTmp5 += vec_code[3][3] * vec_code[4][3];

	return true;
}

unsigned int nTbl[65][65][65][65];
void InitTbl()
{
	for (unsigned char a = 0; a < 65; a++)
		for (unsigned char b = 0; b < 65; b++)
			for (unsigned char c = 0; c < 65; c++)
				for (unsigned char d = 0; d < 65; d++)
				{
					unsigned char ch1 = a ^ (a >> 3);
					unsigned char ch2 = b ^ (b >> 3);
					unsigned char ch3 = c ^ (c >> 3);
					unsigned char ch4 = d ^ (d >> 3);

					unsigned char ret1 = 4 * ch1 | (ch2 >> 4) & 3;
					unsigned char ret2 = 16 * ch2 | (ch3 >> 2) & 0xF;
					unsigned char ret3 = (ch3 << 6) | ch4 & 0x3F;

					nTbl[a][b][c][d] = (ret1 << 16) + (ret2 << 8) + ret3;
				}
}

string GetKey(unsigned char*p)
{
	unsigned int num = (p[0] << 16) + (p[1] << 8) + p[2];
	string strRet = "error";
	for (unsigned char a = 0; a < 65; a++)
		for (unsigned char b = 0; b < 65; b++)
			for (unsigned char c = 0; c < 65; c++)
				for (unsigned char d = 0; d < 65; d++)
				{
					if (nTbl[a][b][c][d] == num)
					{
						strRet = "";
						strRet += strBigNum[a];
						strRet += strBigNum[b];
						strRet += strBigNum[c];
						strRet += strBigNum[d];
						return strRet;
					}
				}
	return strRet;
}
//base64 加密解密结束
//////////////////////////////////////////////////////////////////////////////////////////////

int main()
{
	InitTbl();
	string strUserName;
	cout << "请输入格式为xxxx#xxxx#xxxx#xxxx#xxxx#xxxx#xxxx#xxxx的UserName:" << endl;
	cin >> strUserName;

	_int64 nTmp1, nTmp2, nTmp3, nTmp4,nTmp5;
	if (!CalcCode(strUserName, nTmp1, nTmp2, nTmp3, nTmp4, nTmp5))
	{
		cout << "输入的格式不对" << endl;
		system("pause");
		return 0;
	}

	_int64 nTmp6 = (nTmp4 - nTmp2) / (2 * nTmp1);
	_int64 nTmp7 = nTmp6*nTmp6*nTmp1 + nTmp6*nTmp2 + nTmp3;
	_int64 nTmp8 = nTmp3 + ((nTmp2 + (nTmp1*nTmp5) - nTmp4) * nTmp5);

	unsigned char key[32];
	memset(key, 0, 32);
	memcpy(key, (unsigned char*)&nTmp6, 8);
	memcpy(key+8, (unsigned char*)&nTmp7, 8);
	memcpy(key+16, (unsigned char*)&nTmp8, 8);
	memcpy(key+24, "8102", 4);

	//unsigned char aa[16] = { 0x00,0x10,0x83,0x10,0x51,0x87,0x24,0x82,0xCA,0x34,0xC3,0xCE,0x49,0x34,0x11,0x59 };
	//unsigned char aa[16] = { 0x75,0x15,0x6D,0xA6,0x58,0x7D,0xE7,0x5C,0x92,0x59,0xA7,0x82,0x18,0xA3,0xB6,0xC9 };
	
	//aes_decrypt(aa);

	aes_encrypt(key);
	aes_encrypt(key+16);

	cout << "RegCode:";
	cout << GetKey(key);
	cout << GetKey(key + 3);
	cout << GetKey(key + 6);
	cout << GetKey(key + 9);
	cout << GetKey(key + 12);
	cout << GetKey(key + 15);
	cout << GetKey(key + 18);
	cout << GetKey(key + 21);
	cout << GetKey(key + 24);
	cout << GetKey(key + 27);
	//cout << GetKey(key + 30);
	
	//最后两个字节特殊处理
	for (unsigned char a = 0; a < 65; a++)
		for (unsigned char b = 0; b < 65; b++)
			for (unsigned char c = 0; c < 65; c++)
			{
				unsigned char ch1 = a ^ (a >> 3);
				unsigned char ch2 = b ^ (b >> 3);
				unsigned char ch3 = c ^ (c >> 3);

				unsigned char ret1 = (4 * ch1 | (ch2 >> 4) & 3);
				unsigned char ret2 = (16 * ch2 | (ch3 >> 2) & 0xF);

				if (key[30] == ret1  && key[31] == ret2)
				{
					string strRet = "";
					strRet += strBigNum[a];
					strRet += strBigNum[b];
					strRet += strBigNum[c];

					//最后加上字符串"=="
					cout << strRet << "=" << endl;
					goto CEnd;
				}
			}
CEnd:
	system("pause");
	return 0;
}